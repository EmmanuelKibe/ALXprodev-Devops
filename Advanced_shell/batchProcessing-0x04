#!/bin/bash

# Pokémon list
POKEMONS=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")

# Output directory
OUTPUT_DIR="pokemon_data"
mkdir -p "$OUTPUT_DIR"

# Error log
ERROR_FILE="errors.txt"
> "$ERROR_FILE"

# Max retries
MAX_RETRIES=3
# Maximum allowed time per fetch (seconds)
TIMEOUT=10

# Function to fetch a Pokémon with retries
fetch_pokemon() {
    local name="$1"
    local retries=$MAX_RETRIES
    local success=0

    for ((i=1; i<=retries; i++)); do
        http_code=$(curl -s -m $TIMEOUT -w "%{http_code}" -o "$OUTPUT_DIR/$name.json" "https://pokeapi.co/api/v2/pokemon/$name")
        if [ "$http_code" -eq 200 ]; then
            echo "Saved $name to $OUTPUT_DIR/$name.json ✅"
            success=1
            break
        else
            echo "$name failed attempt $i"
            sleep 1
        fi
    done

    if [ $success -eq 0 ]; then
        echo "Failed to fetch $name" >> "$ERROR_FILE"
    fi
}

# Launch all fetches in parallel and store their PIDs
PIDS=()
for pokemon in "${POKEMONS[@]}"; do
    fetch_pokemon "$pokemon" &
    PIDS+=($!)
done

# List background jobs
echo "Current background jobs:"
jobs

# Example: Kill any job that has been running too long (safely demonstrating kill)
# Here, we simply check after 5 seconds and kill any still running as a demonstration
sleep 5
for pid in "${PIDS[@]}"; do
    if kill -0 "$pid" 2>/dev/null; then
        echo "Terminating stuck process $pid using kill"
        kill "$pid"
    fi
done

# Wait for all remaining jobs to complete
wait

echo "All Pokémon data fetching processes completed."
